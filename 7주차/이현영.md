# 6. 리액트 개발 도구로 디버깅하기

# 6.1. 리액트 개발 도구란?

- `react-dev-tools`
- `React`로 만들어진 모든 애플리케이션 디버깅 가능

# 6.2. 리액트 개발 도구 설치

- 브라우저 확장 프로그램 설치
- 리액트 로고 빨간색 → 리액트 개발 모드
- 리액트 로고 파란색 → 리액트 프로덕션 모드

# 6.3. 리액트 개발 도구 활용하기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2c8ffad2-5e37-4674-9d7e-ceaad4d40679/48c9cc3b-e5cc-408d-9afb-e0087ab08c4b/Untitled.png)

## 6.3.1. Components

### 컴포넌트 트리

- 기명 함수로 컴포넌트가 선언되었다면 → 해당 컴포넌트명 보여줌
- 익명 함수로 컴포넌트가 선언되었다면 → `Anonymous`
- `default`로 내보내진 익명 함수 컴포넌트를 사용한다면 → `_default`

- 기명 함수를 사용하자.
- 그게 어렵다면 `displayName` 속성을 추가하자.

### 컴포넌트명과 props

- 컴포넌트명과 `key` 제공
- 컴포넌트 도구
  - 눈 아이콘 → 해당 컴포넌트가 `HTML`의 어디에서 렌더링됐는지 확인 가능
  - 벌레 아이콘 → 해당 컴포넌트의 정보가 콘솔 탭에 `console.log`로 찍힘
    - 컴포넌트가 받는 `props`
    - 컴포넌트 내부에서 사용하는 `hooks`
    - 컴포넌트의 `nodes`
  - 소스코드 아이콘 → 해당 컴포넌트의 소스코드 확인 가능
    - `{}` 아이콘을 누르면 난독화되어 있던 코드에 여백과 줄바꿈을 준다.
- 컴포넌트 `props`
  - 우클릭 시 복사가능
  - 값이 함수인 경우, 우클릭 후 `Go to definition` 선택 시 해당 함수가 선언된 코드로 이동 및 수정 가능
- 컴포넌트 `hooks`
  - 실제 훅 → 표시명
    - `useState` → `State`
    - `useReducer` → `Reducer`
    - `useContext` → `Context`
    - `useMemo` → `Memo`
    - `useCallback` → `Callback`
    - `useRef` → `Ref`
    - `useId` → `id`
    - `useLayoutEffect` → `LayoutEffect`
    - `useEffect` → `Effect`
    - 리액트에서 제공되는 훅이 아닌 경우 (`useXXX`로 선언되어 있는 사용자 정의 훅) → `XXX`
  - 훅에 넘겨주는 함수를 기명 함수로 넘겨주면 이름 확인 가능!
  - 더블클릭으로 수정 가능
- `rendered by`
  - 해당 컴포넌트를 렌더링한 주체 확인 가능
  - 프로덕션 모드 → `react-dom` 버전 확인
  - 개발 모드 → 렌더링한 부모 컴포넌트

## 6.3.2. Profiler

- 리액트가 렌더링되는 과정에서 어떤 컴포넌트가, 몇 차례나, 얼마나 걸려서 렌더링 되었는지 확인 가능
- 프로덕션 모드가 아닌 개발 모드에서 확인 가능

### 설정 변경하기

- General > Highlight updatees when components render
  - 렌더링 하이라이팅
- Debugging > Hide logs during second render in Strict Mode
  - 리액트 앱이 `strict mode`에서 실행되는 경우, 원활한 디버깅을 위해 `useEffect`가 두 번씩 작동.
  - 이 때문에 그 안의 `console.log`가 두 번씩 찍히기도 하는데, 이를 막아줌
- Profiler > Record why each component rendered while profiling
  - 프로파일링 도중 무엇 때문에 컴포넌트가 렌더링되었는지 기록

### 프로파일링

- 프로파일링 메뉴
  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2c8ffad2-5e37-4674-9d7e-ceaad4d40679/48463954-fe9c-449d-98d0-3aa45a86202f/Untitled.png)
  - 프로파일링 시작
  - 새로고침 후 프로파일링 시작
  - 프로파일링 종료
  - 프로파일 불러오기
  - 프로파일 저장하기
- `Flamegraph`
  - 불꽃 모양 아이콘
  - 렌더 커밋별로 어떠한 작업이 일어났는지 나타냄
  - 렌더링되지 않은 컴포넌트는 회색으로 표시
- `Ranked`
  - 해당 커밋에서 렌더링하는 데 오랜 시간이 걸린 컴포넌트를 순서대로 나열
  - 렌더링이 발생한 컴포넌트만 보여줌
- `타임라인`
  - 리액트 18 이상에서만 확인 가능
  - 시간이 지남에 따라 컴포넌트에서 어떤 일이 일어났는지 확인 가능
  - ex) `input`에 글자를 입력하면서 `state`의 값이 업데이트되고, 이 값이 동기로 업데이트됐는지, 언제 업데이트가 이뤄졌는지 확인 가능

# 7. 크롬 개발자 도구를 활용한 애플리케이션 분석

# 7.1. 크롬 개발자 도구란?

- 시크릿 모드(개인정보 보호 모드)에서 개발자 도구를 열자.
  → 브라우저에 설치되어 있는 각종 확장 프로그램 때문
  → 디버깅에 방해

# 7.2. 요소(Element) 탭

## 7.2.1. 요소 화면

- 요소를 직접 수정 가능 → 코드를 수정해 핫 리로딩을 거치지 않아도 확인 가능
- 클래스, 속성값이 동적으로 제어되는 `DOM` → 요소의 중단점을 사용해 디버깅 가능
  - 하위 트리 수정
  - 속성 수정
  - 노드 삭제

## 7.2.2. 요소 정보

- `Styles`
- `Computed`
- `Layout`
- `Event Listeners`
  - 현재 요소에 부착된 이벤트 리스너
  - 상위 버튼 체크 해제 시 딱 해당 요소의 이벤트 리스너만 볼 수 있음
  - 이벤트 버블링으로 이벤트 발생시키는 경우에는 확인불가
- `DOM Breakpoints`
- `Properties`
  - 해당 요소가 가지고 있는 모든 속성값
  - `JS`로 `.attributes` 실행 → 직접 할당된 값만 나옴
- `Accessibility`
  - 스크린리더기가 활용하는 값

# 7.3. 소스 탭

- 소스 중단점을 생성해 디버깅 수행 가능
- 소스코드를 오염시키지 않아 코드에 `debugger`를 선언하는 것보다 더 유용

- `Watch`
  - 감시하고 싶은 변수 선언 → 해당 변수 정보 확인 가능
  - 확인할 수 없는 값은 `<not abailable>` 로 표시
- `Breakpoints`
  - 웹페이지 전체에 걸쳐 소스 탭에서 추가한 모든 중단점 확인 가능
- `Scope`
  - 로컬 스코프, 클로저, 전역 스코프 등 확인 가능
- `Call Stack`
- `Global Listeners`
  - 전역 스코프에 추가된 리스너 목록

# 7.4. 네트워크 탭

- `Screenshots`
  - 웹페이지의 로딩 과정을 시각적으로 확인 가능
- 네트워크 탭을 통해 집중적으로 확인해 봐야 하는 점
  - 불필요한 요청 또는 중복되는 요청이 없는지
  - 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
  - 리소스를 불러오는 속도는 적절한지
  - 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

# 7.5. 메모리 탭

- `Heap snapshot`
  - 현재 메모리 상황을 사진 찍듯이 촬영 가능
- `Allocation instrumentation on timeline`
  - 시간의 흐름에 따른 메모리의 변화
  - 로딩과정 / 페이지 상호작용 시 메모리의 변화를 알고 싶을 때 사용
- `Allocation sampling`
  - 메모리 공간을 차지하고 있는 자바스크립트 함수

## 7.5.1. 자바스크립트 인스턴스 VM 선택

- 개발자가 디버깅하고 싶은 자바스크립트 VM 환경을 선택하면 된다
- 환경별 힙 크기 볼 수 있다 (해당 페이지가 자바스크립트 힙을 얼마나 점유하고 있는지)

## 7.5.2. 힙 스냅샷

1. 현재 힙 스냅샷 찍기
2. 의심되는 코드 인터렉션 후 스냅샷 찍기
3. 모든 객체 메뉴 클릭 > 스냅샷 1에서 스냅샷 2 사이에 할당된 객체 클릭
4. 얕은 크기 항목 기준 내림차순 정렬

- 얕은 크기 vs 유지된 크기

  - 얕은 크기 → 객체 자체가 보유하는 메모리 바이트의 크기
  - 유지된 크기 → **객체 자체의 크기** + 다른 부모가 존재하지 않는 모든 자식 객체들의 크기(**객체가 참조하고 있는 모든 객체들의 크기**)
    <aside>
    💡 즉, 메모리 누수를 찾을 때는 **얕은 크기와 유지된 크기의 차이가 큰 객체를 최우선으로 찾아야 한다.** → 다수의 다른 객체를 참조하고 있다는 뜻이며, 이러한 객체가 오랜 시간 동안 메모리에 남아있다면 그로 인해 많은 메모리를 점유하고 있을 수 있기 때문!

    </aside>

- 스냅샷에는 많은 내용이 담겨있기 때문에, 하나만 살펴보기 보다는 두 개 이상의 스냅샷을 비교하는 것이 더 수월하다.
- 전역 변수로 저장하여 값 볼 수 있다

## 7.5.3. 타임라인 할당 계측

- 전역 변수로 저장하여 값 볼 수 있다

## 7.5.4. 할당 샘플링

- 시간의 흐름에 따라 발생하는 메모리 점유를 확인가능 → 타임라인 할당 계측과 유사
- **자바스크립트 실행 스택별로 함수 단위 분석 가능하다는 차이점**
- **소스 패널에 표시**하여 해당 함수가 어느 파일에서 어떻게 정의됐는지 확인 가능

- 브라우저에 주는 부담을 최소화할 수 있어, **장시간 디버깅을 수행해야 할 때 유리**
- **정확히 어디에서 메모리 누수가 발생하는지 확인하기 어려운 경우** 유리

# 7.6. Next.js 환경 디버깅하기

서버 환경을 크롬 개발자 도구로 디버깅하는 방법을 알아보자!

## 7.6.1. Next.js 프로젝트를 디버그 모드로 실행하기

1. `package.json` `script` 설정

```json
// package.json

"dev": NODE_OPTIONS='--inspect' next dev
```

1. `next.js` `dev` 실행

```bash
npm run dev
```

1. 크롬 브라우저에서 `chrome://inspect`로 이동 > Open dedicated DevTools for Node 클릭

## 7.6.2. Next.js 서버에 트래픽 유입시키기

- 오픈소스 도구인 `ab`를 사용하기
  ```bash
  ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
  ```
  - `http://127.0.0.1:3000/` 를 향해,
  - 한 번에 50개의 요청을,
  - 총 10000 번 시도
    <aside>
    💡 주소를 `localhost`로 하면 정상적으로 실행되지 않음 주의

    </aside>

## 7.6.3. Next.js의 메모리 누수 지점 확인하기

7.5장의 방법들을 사용하자.
