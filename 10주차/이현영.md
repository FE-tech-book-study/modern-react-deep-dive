# 10.1. 리액트 17 버전 살펴보기

- 새롭게 추가된 기능은 없다.
- 호환성이 깨지는(버전 변경 시 코드 수정 필요) 변경 사항을 최소화

# 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17부터는 이전 코드를 갈아엎지 않고도, 점진적 업데이트가 가능해졌다.
- 버전이 다른 리액트 공존 가능

  ```jsx
  // 구 리액트 애플리케이션 루트
  export default function createLagacyRoot(container) {
  	/* ... */
  }

  // 리액트 16의 루트 가져오는 코드
  // 컴포넌트 불러오는 작업 -> 외부 리액트 버전 수행
  // 컴포넌트 렌더링 작업 -> 내부 리액트 버전 수행
  export default function lazyLagacyRoot(getLagacyComponent) {
  	/* ... */

  	return function Wrapper(props) {
  		// lazy하게 createLagacyRoot 불러오기
  		const createLagacyRoot = readModule(rendererModule, () => import("../legach/createLagacyRoot")).default;

  		// 여기에 리액트 16 코드 렌더링
  		const containerRef = useRef(null);

  		/* ... */

  		return <div ref={containerRef} />;
  }
  ```

- 사용예시

  ```jsx
  // 리액트 16으로 작성된 컴포넌트
  const Greeting = lazyLagacyRoot(() => import("../lagacy/Greeting"));

  function Page() {
    return (
      <>
        <h3> 여기는 리액트 17이지만 {React.version}</h3>
        // 여기서는 16 컴포넌트 사용
        <Greeting />
      </>
    );
  }
  ```

# 10.1.2 이벤트 위임 방식의 변경

- 리액트 버튼 vs 자바스크립트 핸들러 버튼

  - “리액트 버튼”
    - `onClick` 이벤트에 `noop`이라는 핸들러 추가 → 아무 연산도 하지 않음
  - “그냥 버튼”
    - 이벤트 리스너에 `click`으로 추가

  ```tsx
  import { useEffect, useRef } from "react";

  export default function Button() {
    const buttonRef = useRef<HTMLButtonElement | null>(null);

    useEffect(() => {
      if (buttonRef.current) {
        buttonRef.current.onclick = function click() {
          alert("안녕하세요!");
        };
      }
    }, []);

    function 안녕하세요() {
      alert("안녕하세요!");
    }

    return (
      <>
        <button onClick={안녕하세요}>리액트 버튼</button>
        <button ref={buttonRef}>그냥 버튼</button>
      </>
    );
  }
  ```

- 어떻게 동일하게 동작할 수 있었을까?

  - 리액트는 이벤트 핸들러를 각각의 DOM 요소에 부착하는 것이 아니라,
  - 이벤트 타입 당 하나의 핸들러를 루트에 부착한다. → **이벤트 위임**

- 이벤트의 단계

  1. **캡처(capture)**
     - 이벤트 핸들러가 트리 최상단 요소 → 타깃 요소까지 내려가는 것
  2. **타깃(target)**
     - 이벤트 핸들러가 타깃 노드에 도달
     - 이벤트가 호출됨
  3. **버블링(bubbling)**
     - 이벤트가 발생한 요소 → 최상위 요소로 올라가는 것

- 리액트 16까지는 이러한 이벤트 위임이 `document`에서 수행
- 리액트 17부터는 **컴포넌트 최상단 트리인 루트 요소**에서 이벤트 위임 수행
  → 각 **이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리**, 이벤트 버블링으로 인한 혼선 방지

# 10.1.3 import React from “react”가 더 이상 필요 없다: 새로운 JSX transform

- 필요 없어진 이유?

  - 구 버전 JSX 변환 → `React.createElement` 를 위한 `React` import 필요
    ```tsx
    var Component = React.createElement(
      "div",
      null
      /* ... */
    );
    ```
  - 17 버전 JSX 변환 → `require` 구문으로 JSX 변환 시 필요한 모듈 불러옴

    ```tsx
    "use strict";

    var _jsxRuntime = require("react/jsx-runtime");

    var Component = (0, _jsxRuntime.jsx)("div", {
      /* ... */
    });
    ```

- `import React` 한번에 삭제하기
  ```bash
  npx react-codemod update-react-imports
  ```

# 10.1.4 그 밖의 주요 변경 사항

## 이벤트 풀링 제거

- **~React 16**
  - 리액트에는 이벤트를 처리하기 위한 `SyntheticEvent`라는 이벤트가 있었다.
  - `SyntheticEvent` 이벤트란, 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체이다.
  - 즉 이벤트 발생마다 이 이벤트를 새로 생성했었다. → **메모리 할당 작업**이 일어났다.
  - 또 메모리 누수를 방지하기 위해 이렇게 만든 **이벤트를 주기적으로 해제해줬어야** 했다.
  - **이벤트 풀링**이란?
    - `SyntheticEvent` 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것
  - 이벤트 풀링 시스템에서의 이벤트 발생
    1. 이벤트 핸들러가 이벤트 발생시킴
    2. `SyntheticEvent` 풀에서 `SyntheticEvent` 객체에 대한 참조를 가져옴
    3. 발생된 이벤트 정보를 `SyntheticEvent` 객체에 넣어줌
    4. 유저가 지정한 이벤트 리스너 실행
    5. 이벤트 객체 초기화(`null`), 다시 이벤트 풀로 돌아감
- **React 17**
  - 이벤트 풀링 개념 삭제

## useEffect 클린업 함수의 비동기 실행

- **~React 16**
  - `useEffect` 클린업 함수 동기적 처리
- **React 17**
  - 화면이 완전히 업데이트된 이후 `useEffect` 클린업 함수 비동기 처리
  - **클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연** → 커밋타임 조금이나마 단축 가능

## 컴포넌트의 undefined 반환에 대한 일관적인 처리

- **~React 16**
  - 컴포넌트 내부에서 `undefined` 반환 시 에러 발생
  - 그러나 `forwardRef`나 `memo`에서 `undefined` 반환 시 에러 발생 X
- **React 17**
  - 모든 컴포넌트 내부에서 `undefined` 반환 시 에러 발생
- **React 18**
  - 모든 컴포넌트 내부에서 `undefined` 반환 시 에러 발생 X

# 10.2 리액트 18 버전 살펴보기

# 10.2.1 새로 추가된 훅 살펴보기

## useId

- **컴포넌트별로 유니크한 값을 생성**하는 훅
- 서버 사이드 렌더링 환경에서 **하이드레이션**이 일어날 때 **서버와 클라이언트에서 동일한 값을 가져야** 에러가 발생하지 않는다. → 이러한 점도 고려해줌.
- 생성 알고리즘
  - id는 기본적으로 현재 트리 내에서의 자신의 위치를 나타내는 32글자의 이진문자열로 이루어짐
  - 왼쪽 5자리가 부모의 트리를 나타냄
  - 앞 글자가 R → 서버에서 생성된 값
  - 앞 글자가 r → 클라이언트에서 생성된 값

## useTransition

- **UI 변경을 가로막지 않고 상태를 업데이트**할 수 있는 훅
- 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 미룰 수 있음
- 동시성을 다룰 수 있는 훅
- 예를 들어, 각 탭에 무거운 작업이 발생한다고 했을 때, 탭 변경 시 이전 탭의 렌더링을 미루고 새로운 탭의 렌더링을 시작한다.

```jsx
const [isPending, startTransition] = useTransition();
const [tab, setTab] = useState < Tab > "about";

function selectTab(nextTab: Tab) {
  startTransition(() => {
    setTab(nextTab);
  });
}
```

- 인수
  - `isPending` → 상태 업데이트가 진행 중인지를 확인 가능
  - `startTransition` → 긴급하지 않은 상태 업데이트로 간주할 `set` 함수를 넣어둘 수 있는 함수를 인수로 받음
- 컴포넌트에서만 사용 가능한 훅이며, 훅을 사용할 수 없는 상황이라면 `startTransition` 을 바로 import 할 수도 있다.
- 주의할 점
  - `startTransition` 내부에는 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
  - `startTransition` 로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다.
  - `startTransition` 로 넘겨주는 함수는 반드시 동기 함수여야 한다.

## useDeferredValue

- **컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연**할 수 있게 도와주는 훅
- 특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷
- 그러나 디바운스와 다르게,
  - **고정된 지연 시간 없이**
  - 첫 번째 렌더링이 완료된 이후에
  - 지연된 렌더링을 수행한다.
- `useTransition` → `state`를 업데이트하는 함수를 감싸서 사용
- `useDeferredValue` → `state` 값 자체만을 감싸서 사용

## useSyncExternalStore

- `useSubscription`이 이 훅으로 대체되었다.
- **`tearing`**
  - 하나의 `state` 값이 있음에도 서로 다른 값을 기준으로 렌더링되는 현상
- `useTransition` `useDeferredValue` 훅처럼 렌더링을 일시 정지하거나 뒤로 미룰 수 있게 되면서, 이러한 동시성 이슈가 발생할 수 있다.

→ 이러한 문제를 해결하기 위한 훅이다.

- 인수
  - `subscribe` → 콜백 함수를 받아 스토어에 등록하는 용도로 사용
  - 컴포넌트에 필요한 **현재 스토어의 데이터를 반환하는 함수** → 스토어가 변경되지 않았으면 동일한 값 반환, 스토어가 변경됐다면 `Object.is`로 비교 후 다를 경우 컴포넌트 리렌더링
  - 옵셔널 값 → 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션 하는 도중에 사용

## useInsertionEffect

- `CSS-in-JS` 라이브러리를 위한 훅
- 기본적인 구조는 `useEffect`와 동일
- 차이점은 DOM이 실제로 변경되기 전에 동기적으로 실행된다는 것
- `useInsertionEffect` → DOM 변경 작업 → `useLayoutEffect` → DOM 렌더링 → `useEffect`
- 라이브러리 작성이 아닌 실제 애플리케이션 코드에는 가급적 사용하지 말자.

# 10.2.2 react-dom/client

## createRoot

- 기존의 `render` 메서드를 대체할 메서드

## hydrateRoot

- 서버 사이드 렌더링에서 하이드레이션을 하기 위한 새로운 메서드

→ 두 API는 새로운 옵션인 `onRecoverableError` 를 인수로 받는다. 리액트가 렌더링 또는 하이드레이션 과정에서 에러가 발생했을 때 실행하는 콜백 함수.

# 10.2.3 react-dom/server

## renderToPipeableStream

- 리액트 컴포넌트를 HTML로 렌더링하는 메서드
- 스트림 지원
  - HTML을 점진적으로 렌더링, 클라이언트에서는 중간에 script를 삽입하는 등의 작업 가능
  - 서버에서는 Suspense를 이용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링 가능
- `hydrateRoot` 를 호출하면,
  - 서버에서는 HTML을 렌더링하고,
  - 클라이언트에서는 여기에 이벤트만 추가함으로써 첫 번째 로딩을 매우 빠르게 수행 가능

## renderToReadableStream

- `renderToPipeableStream` → Node.js 환경에서의 렌더링을 위해 사용
- `renderToReadableStream` → 웹 스트림을 기반으로 작동

# 10.2.4 자동 배치(Automatic Batching)

- 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 실행하는 방법
- 리액트 18부터는 루트 컴포넌트를 `createRoot` 를 사용해서 만들면 동기, 비동기, 이벤트 핸들러에 상관 없이 모든 업데이트가 배치 작업으로 최적화된다.
- 이러한 자동 배치를 사용하고 싶지 않다면 `flushSync`를 사용하자.

# 10.2.5 더욱 엄격해진 엄격 모드

- 개발자 모드에서만 작동

## 리액트의 엄격 모드

- **더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고**
  - 클래스형 컴포넌트에서 사용되는 생명주기 메서드들을 사용하는 경우
- **문자열 `ref` 사용 금지**
- **`findDOMNode`에 대한 경고 출력**
  - `findDOMNode` → 클래스 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 메서드
  - 이를 사용하는 경우
- **구 `Context API` 사용 시 발생하는 경고**
- **예상치 못한 사이드 이펙트 검사**
  - 클래스 컴포넌트의 `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`
  - 클래스 컴포넌트의 `setState`의 첫 번째 인수
  - 함수 컴포넌트의 body
  - `useState`, `useMemo`, `useReducer`에 전달되는 함수
    → 사이드 이펙트 검사를 위해 엄격 모드에서는 이러한 내용들을 이중으로 호출한다.

## 리액트 18에서 추가된 엄격 모드

- 앞으로 있을 기능 추가를 위한 엄격 모드
  - 예를 들어, 사용자가 화면의 탭을 눌렀다가 다시 돌아왔을 때 리액트는 이전 화면을 즉시 표시할 수 있어야 한다.
  - 이를 위해 리액트는 이전과 동일한 컴포넌트 상태를 사용해 트리를 마운트 해제, 다시 마운트한다.
  - 컴포넌트가 이펙트를 여러 번 마운트 및 제거해도 복원력이 있어야 한다.
- 이러한 검사를 위해 고의로 `useEffect`를 두 번 작동
- `useEffect` 를 사용할 때 반드시 적절한 `cleanup` 함수를 배치해서 반복 실행될 수 있는 `useEffect` 로부터 최대한 자유로운 컴포넌트를 만들자.

# 10.2.6 Suspense 기능 강화

- 18버전 이전의 `Suspense`
  - 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능
  - 인수
    - `fallback`
    - `React.lazy`로 선언한 지연 컴포넌트
  - 문제점
    - 컴포넌트가 아직 보이기도 전에 `useEffect`가 실행되는 문제
    - 서버에서 사용할 수 없음
- 18버전의 `Suspense`
  - 문제점이었던 마운트 이전 `effect` 실행 문제 해결
  - `Suspense` 로 인해 컴포넌트가 보이거나 사라질 때도 `effect` 정상적 실행
  - 서버에서도 실행 가능!!
  - `스로틀링` 추가 → 다음 렌더링을 보여주기 전에 잠시 대기

# 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- 이제 리액트는 다음과 같은 최신 자바스크립트 기능을 사용할 수 있다는 가정 하에 배포된다.
  - `Promise`
  - `Symbol`
  - `Object.assign`

# 10.2.8 그 밖에 알아두면 좋은 변경사항

- 이제 컴포넌트에서 `undefined`를 반환해도 에러가 발생하지 않는다. → `null` 반환과 동일하게 처리
- `<Suspense fallback={undefined}>` 도 마찬가지이다. → `null` 과 동일하게 처리
- `renderToNodeStream` 지원 중단 → 대신 `renderToPipeableStream` 사용 권장
